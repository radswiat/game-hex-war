import * as THREE from 'three'

/**
 * Builds one or many THREE.Mesh from one raw set of Arraybuffers, materialGroup descriptions and further parameters.
 * Supports vertex, vertexColor, normal, uv and index buffers.
 * @class
 */
THREE.LoaderSupport.MeshBuilder = function() {
  console.info( 'Using THREE.LoaderSupport.MeshBuilder version: ' + THREE.LoaderSupport.MeshBuilder.LOADER_MESH_BUILDER_VERSION );
  this.validator = THREE.LoaderSupport.Validator;

  this.logging = {
    enabled: true,
    debug: false
  };

  this.callbacks = new THREE.LoaderSupport.Callbacks();
  this.materials = [];
};
THREE.LoaderSupport.MeshBuilder.LOADER_MESH_BUILDER_VERSION = '1.3.0';

THREE.LoaderSupport.MeshBuilder.prototype = {

  constructor: THREE.LoaderSupport.MeshBuilder,

  /**
   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.
   *
   * @param {boolean} enabled True or false.
   * @param {boolean} debug True or false.
   */
  setLogging: function ( enabled, debug ) {
    this.logging.enabled = enabled === true;
    this.logging.debug = debug === true;
  },

  /**
   * Initializes the MeshBuilder (currently only default material initialisation).
   *
   */
  init: function () {
    var defaultMaterial = new THREE.MeshStandardMaterial( { color: 0xDCF1FF } );
    defaultMaterial.name = 'defaultMaterial';

    var defaultVertexColorMaterial = new THREE.MeshStandardMaterial( { color: 0xDCF1FF } );
    defaultVertexColorMaterial.name = 'defaultVertexColorMaterial';
    defaultVertexColorMaterial.vertexColors = THREE.VertexColors;

    var defaultLineMaterial = new THREE.LineBasicMaterial();
    defaultLineMaterial.name = 'defaultLineMaterial';

    var defaultPointMaterial = new THREE.PointsMaterial( { size: 1 } );
    defaultPointMaterial.name = 'defaultPointMaterial';

    var runtimeMaterials = {};
    runtimeMaterials[ defaultMaterial.name ] = defaultMaterial;
    runtimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;
    runtimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;
    runtimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;

    this.updateMaterials(
      {
        cmd: 'materialData',
        materials: {
          materialCloneInstructions: null,
          serializedMaterials: null,
          runtimeMaterials: runtimeMaterials
        }
      }
    );
  },

  /**
   * Set materials loaded by any supplier of an Array of {@link THREE.Material}.
   *
   * @param {THREE.Material[]} materials Array of {@link THREE.Material}
   */
  setMaterials: function ( materials ) {
    var payload = {
      cmd: 'materialData',
      materials: {
        materialCloneInstructions: null,
        serializedMaterials: null,
        runtimeMaterials: this.validator.isValid( this.callbacks.onLoadMaterials ) ? this.callbacks.onLoadMaterials( materials ) : materials
      }
    };
    this.updateMaterials( payload );
  },

  _setCallbacks: function ( callbacks ) {
    if ( this.validator.isValid( callbacks.onProgress ) ) this.callbacks.setCallbackOnProgress( callbacks.onProgress );
    if ( this.validator.isValid( callbacks.onReportError ) ) this.callbacks.setCallbackOnReportError( callbacks.onReportError );
    if ( this.validator.isValid( callbacks.onMeshAlter ) ) this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter );
    if ( this.validator.isValid( callbacks.onLoad ) ) this.callbacks.setCallbackOnLoad( callbacks.onLoad );
    if ( this.validator.isValid( callbacks.onLoadMaterials ) ) this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials );
  },

  /**
   * Delegates processing of the payload (mesh building or material update) to the corresponding functions (BW-compatibility).
   *
   * @param {Object} payload Raw Mesh or Material descriptions.
   * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh} or null in case of material update
   */
  processPayload: function ( payload ) {
    if ( payload.cmd === 'meshData' ) {

      return this.buildMeshes( payload );

    } else if ( payload.cmd === 'materialData' ) {

      this.updateMaterials( payload );
      return null;

    }
  },

  /**
   * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).
   *
   * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.
   * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh}
   */
  buildMeshes: function ( meshPayload ) {
    var meshName = meshPayload.params.meshName;

    var bufferGeometry = new THREE.BufferGeometry();
    bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.vertices ), 3 ) );
    if ( this.validator.isValid( meshPayload.buffers.indices ) ) {

      bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( meshPayload.buffers.indices ), 1 ));

    }
    var haveVertexColors = this.validator.isValid( meshPayload.buffers.colors );
    if ( haveVertexColors ) {

      bufferGeometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.colors ), 3 ) );

    }
    if ( this.validator.isValid( meshPayload.buffers.normals ) ) {

      bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.normals ), 3 ) );

    } else {

      bufferGeometry.computeVertexNormals();

    }
    if ( this.validator.isValid( meshPayload.buffers.uvs ) ) {

      bufferGeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.uvs ), 2 ) );

    }

    var material, materialName, key;
    var materialNames = meshPayload.materials.materialNames;
    var createMultiMaterial = meshPayload.materials.multiMaterial;
    var multiMaterials = [];
    for ( key in materialNames ) {

      materialName = materialNames[ key ];
      material = this.materials[ materialName ];
      if ( createMultiMaterial ) multiMaterials.push( material );

    }
    if ( createMultiMaterial ) {

      material = multiMaterials;
      var materialGroups = meshPayload.materials.materialGroups;
      var materialGroup;
      for ( key in materialGroups ) {

        materialGroup = materialGroups[ key ];
        bufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );

      }

    }

    var meshes = [];
    var mesh;
    var callbackOnMeshAlter = this.callbacks.onMeshAlter;
    var callbackOnMeshAlterResult;
    var useOrgMesh = true;
    var geometryType = this.validator.verifyInput( meshPayload.geometryType, 0 );
    if ( this.validator.isValid( callbackOnMeshAlter ) ) {

      callbackOnMeshAlterResult = callbackOnMeshAlter(
        {
          detail: {
            meshName: meshName,
            bufferGeometry: bufferGeometry,
            material: material,
            geometryType: geometryType
          }
        }
      );
      if ( this.validator.isValid( callbackOnMeshAlterResult ) ) {

        if ( callbackOnMeshAlterResult.isDisregardMesh() ) {

          useOrgMesh = false;

        } else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {

          for ( var i in callbackOnMeshAlterResult.meshes ) {

            meshes.push( callbackOnMeshAlterResult.meshes[ i ] );

          }
          useOrgMesh = false;

        }

      }

    }
    if ( useOrgMesh ) {

      if ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();
      if ( geometryType === 0 ) {

        mesh = new THREE.Mesh( bufferGeometry, material );

      } else if ( geometryType === 1) {

        mesh = new THREE.LineSegments( bufferGeometry, material );

      } else {

        mesh = new THREE.Points( bufferGeometry, material );

      }
      mesh.name = meshName;
      meshes.push( mesh );

    }

    var progressMessage;
    if ( this.validator.isValid( meshes ) && meshes.length > 0 ) {

      var meshNames = [];
      for ( var i in meshes ) {

        mesh = meshes[ i ];
        meshNames[ i ] = mesh.name;

      }
      progressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;
      progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';

    } else {

      progressMessage = 'Not adding mesh: ' + meshName;
      progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';

    }
    var callbackOnProgress = this.callbacks.onProgress;
    if ( this.validator.isValid( callbackOnProgress ) ) {

      var event = new CustomEvent( 'MeshBuilderEvent', {
        detail: {
          type: 'progress',
          modelName: meshPayload.params.meshName,
          text: progressMessage,
          numericalValue: meshPayload.progress.numericalValue
        }
      } );
      callbackOnProgress( event );

    }

    return meshes;
  },

  /**
   * Updates the materials with contained material objects (sync) or from alteration instructions (async).
   *
   * @param {Object} materialPayload Material update instructions
   */
  updateMaterials: function ( materialPayload ) {
    var material, materialName;
    var materialCloneInstructions = materialPayload.materials.materialCloneInstructions;
    if ( this.validator.isValid( materialCloneInstructions ) ) {

      var materialNameOrg = materialCloneInstructions.materialNameOrg;
      var materialOrg = this.materials[ materialNameOrg ];

      if ( this.validator.isValid( materialNameOrg ) ) {

        material = materialOrg.clone();

        materialName = materialCloneInstructions.materialName;
        material.name = materialName;

        var materialProperties = materialCloneInstructions.materialProperties;
        for ( var key in materialProperties ) {

          if ( material.hasOwnProperty( key ) && materialProperties.hasOwnProperty( key ) ) material[ key ] = materialProperties[ key ];

        }
        this.materials[ materialName ] = material;

      } else {

        console.warn( 'Requested material "' + materialNameOrg + '" is not available!' );

      }
    }

    var materials = materialPayload.materials.serializedMaterials;
    if ( this.validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {

      var loader = new THREE.MaterialLoader();
      var materialJson;
      for ( materialName in materials ) {

        materialJson = materials[ materialName ];
        if ( this.validator.isValid( materialJson ) ) {

          material = loader.parse( materialJson );
          if ( this.logging.enabled ) console.info( 'De-serialized material with name "' + materialName + '" will be added.' );
          this.materials[ materialName ] = material;
        }

      }

    }

    materials = materialPayload.materials.runtimeMaterials;
    if ( this.validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {

      for ( materialName in materials ) {

        material = materials[ materialName ];
        if ( this.logging.enabled ) console.info( 'Material with name "' + materialName + '" will be added.' );
        this.materials[ materialName ] = material;

      }

    }
  },

  /**
   * Returns the mapping object of material name and corresponding jsonified material.
   *
   * @returns {Object} Map of Materials in JSON representation
   */
  getMaterialsJSON: function () {
    var materialsJSON = {};
    var material;
    for ( var materialName in this.materials ) {

      material = this.materials[ materialName ];
      materialsJSON[ materialName ] = material.toJSON();
    }

    return materialsJSON;
  },

  /**
   * Returns the mapping object of material name and corresponding material.
   *
   * @returns {Object} Map of {@link THREE.Material}
   */
  getMaterials: function () {
    return this.materials;
  }

};
